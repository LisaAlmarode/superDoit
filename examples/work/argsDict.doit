#!/usr/bin/env superdoit_solo
#
#	add an instance var to script; set the iv; return the iv as the result
#

instvars
opts
args
%
method
specsDictFor: optionsSpec
	| specsDict |
	specsDict := Dictionary new
		at: 'long' put: Dictionary new;
		at: 'short' put: Dictionary new;
		at: 'shortKey' put: Dictionary new;
		yourself.
	optionsSpec do: [:specArray |
		| argSpec |
		argSpec := specArray at: 3.	"#none #required #optional"
		(specArray at: 1) 
			ifNil: [ self error: 'Long option required' ]
			ifNotNil: [:longOption |
				(specsDict at: 'long') 
					at: longOption asString put: argSpec.
				(specArray at: 2) ifNotNil: [:shortOption |
					(specsDict at: 'short') 
						at: shortOption asString put: argSpec.
					(specsDict 
						at: 'shortKey' 
						ifAbsentPut: [ Dictionary new ]) 
							at: shortOption asString put: longOption asString ] ] ].
	^ specsDict
%
method
getOpts: optionsSpec
	| argStream opt optKey theArgs argExpected specsDict |
	specsDict := self specsDictFor: optionsSpec.
	opts := Dictionary new.
	args := {}.
	theArgs := self scriptArgs asArray.
	theArgs size = 1 ifTrue: [ ^self ].
	argStream := ReadStream on: (theArgs copyFrom: 2 to: theArgs size).
	[ argStream atEnd ] 
		whileFalse: [
			| optOrArg |
			optOrArg := argStream next.
			(optOrArg = '--' or: [optOrArg = '-'])
				ifTrue: [ self error: 'Cannot handle naked dashes ', optOrArg printString ].
			(optOrArg beginsWith: '-')
				ifTrue: [ 
					(optOrArg beginsWith: '--')
						ifTrue: [
							opt :=  optOrArg copyFrom: 3 to: optOrArg size.
							(opt indexOf: $= ifAbsent: [])
								ifNotNil: [
"strip out arg and make sure that arg is #required or #optional (not #none)"
"if arg is enclosed in "" then they need to be stripped"]
								ifNil: [
									argExpected := (specsDict at: 'long') 
										at: opt 
										ifAbsent: [self error: 'Unknown option ', opt printString ] ].
							optKey := opt ]
						ifFalse: [
							opt :=  optOrArg copyFrom: 2 to: optOrArg size.
							argExpected := (specsDict at: 'short') 
								at: opt 
								ifAbsent: [self error: 'Unknown option ', opt printString ].
							optKey := (specsDict at: 'shortKey') at: opt ] ]
				ifFalse: [
"if arg is enclosed in "" then they need to be stripped"
					opt 
						ifNil: [ 
							"naked arg"
							args add: optOrArg.
							argExpected := nil ]
						ifNotNil: [ :theOpt |
							argExpected == #none
								ifTrue: [ 
									args add: optOrArg.
									opts at: optKey put: nil ]
								ifFalse: [ opts at: optKey put: optOrArg ].
							argExpected := opt := nil ] ] ].
		opt ifNotNil: [
			"naked option"
			argExpected == #required
				ifTrue: [ self error: 'missing required argument for option ', opt printString ].
			opts at: optKey put: nil ].
%
method
commandSummary
	^ Dictionary new
		at: 'options' put: opts;
		at: 'args' put: args; 
		yourself.
%
doit
"
	TESTED patterns
		argDict.doit 123
		argDict.doit -h
		argDict.doit -h 123
		argDict.doit --help
		argDict.doit --help 123
		argDict.doit -a 123
		argDict.doit --add=123
		argDict.doit -ha 123
"
	self logMessage: '========='.
	self getOpts: 
		{
			#( help h none ) .
			#( add a required ) .
		}.
	self log: self commandSummary.
	self logMessage: '========='.
	opts at: 'help' 
		ifPresent: [:ignored | opts removeKey: 'help' ]
		ifAbsent: [ ].
	opts at: 'add' 
		ifPresent: [:arg | 
			arg = '123' 
				ifFalse: [ self error: 'incorrect required option value ', arg printString, ' for ''add'' option' ].
			opts removeKey: 'add' ]
		ifAbsent: [ ].
	opts isEmpty 
		ifFalse: [
			self log: self commandSummary. 
			self error: 'Unexpected options' ].
	args remove: '123' ifAbsent: [].
	args isEmpty 
		ifFalse: [ 
			self log: self commandSummary. 
			self error: 'Unexpected positional arguments' ].
	'SUCCESS'
%

