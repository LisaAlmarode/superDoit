#!/usr/bin/env superdoit_solo
usage
USAGE $basename [--help | -h] [--required=<something>] \
      [--optional[=<something>] | -o [<something>] ] \
      [--another=<something> | -a <something>] \
      [<something>]...

DESCRIPTION
  Posix long and short argument handling support.

  Specify desired options using an <optionsSpec> which is an array of arrays:

    {
      #( help h none ) .
      #( required nil required ) .
      #( optional o optional ) .
      #( another a required ) .
    }.

    There is an array for each option of the form:

      #( longName shortName [none | required | optional )

    The shortName may be nil.

  When the #getOpts: message is sent with <optionsSpec> as the argument,
    the options are read from the command line and the 'opts' instance variable
    is set to a dictionary of options and the 'args' instance variable is set
    to an array of positional parameters.

  The 'opts' dictionary contains two assocations keyed by 'options' and 'args'. 

  The 'options'  value is a dictionary whose keys are the long names of the 
    options  appearing on the command line and whose values are the value of the
    option specified on the command line. If not value was specified on the
    command line, the value is 'nil'.

  Errors are generated during command line parsing if an option argument is 
    specified when the options spec is #none, or if no option argument is 
    specified when the options spec is #required.

OPTIONS
  [<positional-arguments>...]
    any number of positional arguments may be specified
  --help | -h
    display usage message
  --required=<required-value>
    example of a long option with a required value
  --optional[=<optional-value>] | -o [<optional-value]
    example of a long and short option with an optional value
  --another=<another-required-value>] | -a [<another-required-value]
    example of a long and short option with a required value

EXAMPLES
  $basename --help
  $basename -h
  $basename 123
  $basename 123 456
  $basename --required=123
  $basename --another=123
  $basename -a 123
  $basename --optional
  $basename -o
  $basename --optional=123
  $basename -o 123
  $basename -o 123 -a 456
  $basename -oa 123
  $basename -oa 123 456
  $basename 456 -or 123
  $basename --required=123 --optional=123 --another=123
  $basename --required=123 --optional --another=123
  $basename --required=123 -o
  $basename --required=123 -o 456 789
  $basename --required=123 -oa 123
  $basename --required=123 -o 456 --another=123 789
%
instvars
opts
args
%
method
getOpts: optionsSpec
	| argStream opt optKey theArgs argExpected specsDict |
	specsDict := self _specsDictFor: optionsSpec.
	opts := Dictionary new.
	args := {}.
	theArgs := self scriptArgs asArray.
	theArgs size = 1 ifTrue: [ ^self ].
	argStream := ReadStream on: (theArgs copyFrom: 2 to: theArgs size).
	[ argStream atEnd ] 
		whileFalse: [
			| optOrArg |
			optOrArg := argStream next.
			(optOrArg = '--' or: [optOrArg = '-'])
				ifTrue: [ self error: 'Cannot handle naked dashes ', optOrArg printString ].
			opt 
				ifNotNil: [ :theOpt |
					argExpected == #none
						ifTrue: [ 
							opts at: optKey put: nil.
							opt := nil ]
						ifFalse: [ 
							(optOrArg beginsWith: '-')
								ifTrue: [
									argExpected == #optional
										ifTrue: [ opts at: optKey put: nil ]
										ifFalse: [self error: 'Missing required option argument for option ', optKey printString ] ]
								ifFalse: [ opts at: optKey put: optOrArg ] ].
					optKey := argExpected := nil ].
			(optOrArg beginsWith: '-')
				ifTrue: [ 
					(optOrArg beginsWith: '--')
						ifTrue: [
							opt :=  optOrArg copyFrom: 3 to: optOrArg size.
							(opt indexOf: $= ifAbsent: [])
								ifNotNil: [ :index |
									| arg |
									arg := opt copyFrom: index + 1 to: opt size.
									opt := opt copyFrom: 1 to: index - 1.
									((specsDict at: 'long') 
										at: opt 
										ifAbsent: [ self error: 'Unknown option ', opt printString ]) == #none
											ifTrue: [ self error: 'Unexpected option argument ', arg printString, ' for option ', opt printString ].
									opts at: opt put: arg ]
								ifNil: [
									((specsDict at: 'long') 
										at: opt 
										ifAbsent: [ self error: 'Unknown option ', opt printString ]) == #required
											ifTrue: [ self error: 'Missing required option argument for option ', opt printString ].
									opts at: opt put: nil ].
							argExpected := opt := optKey := nil ]
						ifFalse: [
							"optOrArg beginsWith: '-'"
							| theOpts numOpts |
							theOpts :=  optOrArg copyFrom: 2 to: optOrArg size.
							numOpts := theOpts size.
							1 to: numOpts do: [:index |
								opt := (theOpts at: index) asString.
								argExpected := (specsDict at: 'short') 
									at: opt 
									ifAbsent: [ self error: 'Unknown option ', opt printString ].
								optKey := (specsDict at: 'shortKey') at: opt.
								index < numOpts
									ifTrue: [
										"multiple options"
										argExpected == #required
											ifTrue: [ self error: 'Missing required option argument for option ', opt printString ].
										opts at: optKey put: nil ] ] ] ]
				ifFalse: [
"if arg is enclosed in "" then they need to be stripped"
					opt 
						ifNil: [ 
							"naked arg"
							args add: optOrArg.
							argExpected := nil ]
						ifNotNil: [ optKey := argExpected := opt := nil ] ] ].
		opt ifNotNil: [
			"naked option"
			argExpected == #required
				ifTrue: [ self error: 'missing required argument for option ', opt printString ].
			opts at: optKey put: nil ].
%
method
_specsDictFor: optionsSpec
	| specsDict |
	specsDict := Dictionary new
		at: 'long' put: Dictionary new;
		at: 'short' put: Dictionary new;
		at: 'shortKey' put: Dictionary new;
		yourself.
	optionsSpec do: [:specArray |
		| argSpec |
		argSpec := specArray at: 3.	"#none #required #optional"
		(specArray at: 1) 
			ifNil: [ self error: 'Long option required' ]
			ifNotNil: [:longOption |
				(specsDict at: 'long') 
					at: longOption asString put: argSpec.
				(specArray at: 2) ifNotNil: [:shortOption |
					(specsDict at: 'short') 
						at: shortOption asString put: argSpec.
					(specsDict 
						at: 'shortKey' 
						ifAbsentPut: [ Dictionary new ]) 
							at: shortOption asString put: longOption asString ] ] ].
	^ specsDict
%
method
commandSummary
	^ Dictionary new
		at: 'options' put: opts;
		at: 'args' put: args; 
		yourself.
%
doit
	[
		self getOpts: 
			{
				#( debug D none ) .
				#( help h none ) .
				#( required nil required ) .
				#( optional o optional ) .
				#( another a required ) .
			}.
	] on: Error do: [:ex | 
		opts at: 'debug' ifAbsent: [ ^ ex description ].
		ex pass ].
	opts at: 'help' 
		ifPresent: [:ignored | ^ self usage ]
		ifAbsent: [ ].
	^ self commandSummary
%

