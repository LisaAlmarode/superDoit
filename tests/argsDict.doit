#!/usr/bin/env superdoit_solo
method: SuperDoitCommandParser
options: string
	| optionSpecStream optionSpecs |
	optionSpecs := {}.
	optionSpecStream := string readStreamPortable.
	[ optionSpecStream atEnd ]
		whileFalse: [ 
			| optionSpec spec |
			optionSpec := optionSpecStream nextLine.
			spec := ('#( ', optionSpec, ' )') evaluate.
			optionSpecs add: spec ].
	self dynamicInstVarAt: #optionSpecs put: optionSpecs
%
options
debug D none
help h none
required nil required
optional o optional
another a required
none n none
%
usage
USAGE $basename [--help | -h] [--debug | -D] \
      [--required=<something>] \
      [--optional[=<something>] | -o [<something>] ] \
      [--another=<something> | -a <something>] \
      [--none | -n] [<something>]...

DESCRIPTION
  Posix long and short argument handling support.

  Specify desired options using the 'options' section:

    options
    debug D none
    help h none
    required nil required
    optional o optional
    another a required
    none n none
    %

  where an option is declared on a line with three fields:

    longName shortName [none | required | optional

  The shortName may be nil.

	When the 'options' section is processed the resulting option spec is added to
	  the 'optionSpec' inst var.

  When the #getOpts: message is sent with optionsSpec inst var as the argument,
    the options are read from the command line and the 'opts' instance variable
    is set to a dictionary of options and the 'args' instance variable is set
    to an array of positional parameters.

  The 'opts' dictionary contains two assocations keyed by 'options' and 'args'. 

  The 'options'  value is a dictionary whose keys are the long names of the 
    options  appearing on the command line and whose values are the value of the
    option specified on the command line. If not value was specified on the
    command line, the value is 'nil'.

  Errors are generated during command line parsing if an option argument is 
    specified when the options spec is #none, or if no option argument is 
    specified when the options spec is #required.

OPTIONS
  [<positional-arguments>...]
    Any number of positional arguments may be specified.
  --help | -h
    Display usage message.
  --debug | -D
    Without this option, when an error occurs, the error message is written to
      stdout. If this option is supplied, the error is allowed to bring up the
      topaz debugger.
  --required=<required-value>
    Example of a long option with a required value.
  --optional[=<optional-value>] | -o [<optional-value]
    Example of a long and short option with an optional value.
  --another=<another-required-value>] | -a [<another-required-value]
    Example of a long and short option with a required value.
  --none | -n
    Example of a long and short option with no required value.

EXAMPLES
  $basename --help
  $basename -h
  $basename --debug -required 123 -ona 456
  $basename --none
  $basename -D
  $basename 123
  $basename 123 456
  $basename --required=123
  $basename --another=123
  $basename -a 123
  $basename --optional
  $basename -o
  $basename --optional=123
  $basename -o 123
  $basename -o 123 -a 456
  $basename -oa 123
  $basename -oa 123 456
  $basename 456 -or 123
  $basename --required=123 --optional=123 --another=123
  $basename --required=123 --optional --another=123
  $basename --required=123 -o
  $basename --required=123 -o 456 789
  $basename --required=123 -oa 123
  $basename --required=123 -o 456 --another=123 789
%
instvars
optionSpec
opts
args
%
method
processDynamicSections: aSuperDoitCommandParser
	optionSpec := aSuperDoitCommandParser dynamicInstVarAt: #optionSpecs  
%
method
getOpts: optionsSpec
	| argStream opt optKey theArgs argExpected specsDict |
	specsDict := self _specsDictFor: optionsSpec.
	opts := Dictionary new.
	args := {}.
	theArgs := self scriptArgs asArray.
	theArgs size = 1 ifTrue: [ ^self ].
	argStream := ReadStream on: (theArgs copyFrom: 2 to: theArgs size).
	[ argStream atEnd ] 
		whileFalse: [
			| optOrArg |
			optOrArg := argStream next.
			(optOrArg = '--' or: [optOrArg = '-'])
				ifTrue: [ self error: 'Cannot handle naked dashes ', optOrArg printString ].
			opt 
				ifNotNil: [ :theOpt |
					argExpected == #none
						ifTrue: [ 
							opts at: optKey put: nil.
							opt := nil ]
						ifFalse: [ 
							(optOrArg beginsWith: '-')
								ifTrue: [
									argExpected == #optional
										ifTrue: [ opts at: optKey put: nil ]
										ifFalse: [self error: 'Missing required option argument for option ', optKey printString ] ]
								ifFalse: [ opts at: optKey put: optOrArg ] ].
					optKey := argExpected := nil ].
			(optOrArg beginsWith: '-')
				ifTrue: [ 
					(optOrArg beginsWith: '--')
						ifTrue: [
							opt :=  optOrArg copyFrom: 3 to: optOrArg size.
							(opt indexOf: $= ifAbsent: [])
								ifNotNil: [ :index |
									| arg |
									arg := opt copyFrom: index + 1 to: opt size.
									opt := opt copyFrom: 1 to: index - 1.
									((specsDict at: 'long') 
										at: opt 
										ifAbsent: [ self error: 'Unknown option ', opt printString ]) == #none
											ifTrue: [ self error: 'Unexpected option argument ', arg printString, ' for option ', opt printString ].
									opts at: opt put: arg ]
								ifNil: [
									((specsDict at: 'long') 
										at: opt 
										ifAbsent: [ self error: 'Unknown option ', opt printString ]) == #required
											ifTrue: [ self error: 'Missing required option argument for option ', opt printString ].
									opts at: opt put: nil ].
							argExpected := opt := optKey := nil ]
						ifFalse: [
							"optOrArg beginsWith: '-'"
							| theOpts numOpts |
							theOpts :=  optOrArg copyFrom: 2 to: optOrArg size.
							numOpts := theOpts size.
							1 to: numOpts do: [:index |
								opt := (theOpts at: index) asString.
								argExpected := (specsDict at: 'short') 
									at: opt 
									ifAbsent: [ self error: 'Unknown option ', opt printString ].
								optKey := (specsDict at: 'shortKey') at: opt.
								index < numOpts
									ifTrue: [
										"multiple options"
										argExpected == #required
											ifTrue: [ self error: 'Missing required option argument for option ', opt printString ].
										opts at: optKey put: nil ] ] ] ]
				ifFalse: [
"if arg is enclosed in "" then they need to be stripped"
					opt 
						ifNil: [ 
							"naked arg"
							args add: optOrArg.
							argExpected := nil ]
						ifNotNil: [ optKey := argExpected := opt := nil ] ] ].
		opt ifNotNil: [
			"naked option"
			argExpected == #required
				ifTrue: [ self error: 'missing required argument for option ', opt printString ].
			opts at: optKey put: nil ].
%
method
_specsDictFor: optionsSpec
	| specsDict |
	specsDict := Dictionary new
		at: 'long' put: Dictionary new;
		at: 'short' put: Dictionary new;
		at: 'shortKey' put: Dictionary new;
		yourself.
	optionsSpec do: [:specArray |
		| argSpec |
		argSpec := specArray at: 3.	"#none #required #optional"
		(specArray at: 1) 
			ifNil: [ self error: 'Long option required' ]
			ifNotNil: [:longOption |
				(specsDict at: 'long') 
					at: longOption asString put: argSpec.
				(specArray at: 2) ifNotNil: [:shortOption |
					(specsDict at: 'short') 
						at: shortOption asString put: argSpec.
					(specsDict 
						at: 'shortKey' 
						ifAbsentPut: [ Dictionary new ]) 
							at: shortOption asString put: longOption asString ] ] ].
	^ specsDict
%
method
commandSummary
	^ Dictionary new
		at: 'options' put: opts;
		at: 'args' put: args; 
		yourself.
%
doit
	[
		self getOpts: optionSpec.
	] on: Error do: [:ex | 
		opts at: 'debug' ifAbsent: [ ^ ex description ].
		ex pass ].
	opts at: 'help' 
		ifPresent: [:ignored | ^ self usage ]
		ifAbsent: [ ].
	^ self commandSummary
%

