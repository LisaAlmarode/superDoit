#!/usr/bin/env superdoit_solo
instvars
args
%
options
{
  SuperDoitCommandLineOption long: 'debug' short: 'D'.
  SuperDoitCommandLineOption long: 'help' short: 'h'.
  SuperDoitCommandLineOption long: 'none' short: 'n'.
  SuperDoitRequiredCommandLineOption long: 'required'.
  SuperDoitRequiredCommandLineOption long: 'another' short: 'a'.
  SuperDoitOptionalCommandLineOption long: 'optional' short: 'o' default: '0'.
  SuperDoitOptionalCommandLineOption long: 'noshort' default: '0'.
}
%
usage
USAGE $basename [--help | -h] [--debug | -D] \
      [--required=<something>] \
      [--noshort[=<something>] ] \
      [--optional[=<something>] | -o [<something>] ] \
      [--another=<something> | -a <something>] \
      [--none | -n] [<something>]...

DESCRIPTION
  Posix long and short argument handling support.

  Specify desired options using the 'options' section:

    options
    {
      SuperDoitCommandLineOption long: 'debug' short: 'D'.
      SuperDoitCommandLineOption long: 'help' short: 'h'.
      SuperDoitCommandLineOption long: 'none' short: 'n'.
      SuperDoitRequiredCommandLineOption long: 'required'.
      SuperDoitRequiredCommandLineOption long: 'another' short: 'a'.
      SuperDoitOptionalCommandLineOption long: 'optional' short: 'o' default: '0'.
      SuperDoitOptionalCommandLineOption long: 'noshort' default: '0'.
    }
    %

  where an option is declared on a line with three fields:

    longName shortName [none | required | optional

  The shortName may be nil.

	When the 'options' section is processed the resulting option spec is added to
	  the 'optionSpec' inst var.

  When the #getOpts: message is sent with optionsSpec inst var as the argument,
    the options are read from the command line and the 'opts' instance variable
    is set to a dictionary of options and the 'args' instance variable is set
    to an array of positional parameters.

  The 'opts' dictionary contains two assocations keyed by 'options' and 'args'. 

  The 'options'  value is a dictionary whose keys are the long names of the 
    options  appearing on the command line and whose values are the value of the
    option specified on the command line. If not value was specified on the
    command line, the value is 'nil'.

  Errors are generated during command line parsing if an option argument is 
    specified when the options spec is #none, or if no option argument is 
    specified when the options spec is #required.

OPTIONS
  [<positional-arguments>...]
    Any number of positional arguments may be specified.
  --help | -h
    Display usage message.
  --debug | -D
    Without this option, when an error occurs, the error message is written to
      stdout. If this option is supplied, the error is allowed to bring up the
      topaz debugger.
  --required=<required-value>
    Example of a long option with a required value.
  --optional[=<optional-value>] | -o [<optional-value]
    Example of a long and short option with an optional value. The default value is '0'.
  --noshort[=<optional-value>]
    Example of a long option with an optional value. The default value is '0'.
  --another=<another-required-value>] | -a [<another-required-value]
    Example of a long and short option with a required value.
  --none | -n
    Example of a long and short option with no required value.

EXAMPLES
  $basename --help
  $basename -h
  $basename --debug -required 123 -ona 456
  $basename --none
  $basename -D
  $basename 123
  $basename 123 456
  $basename --required=123
  $basename --another=123
  $basename -a 123
  $basename --noshort
  $basename --noshort=123
  $basename --optional
  $basename -o
  $basename --optional=123
  $basename -o 123
  $basename -o 123 -a 456
  $basename -oa 123
  $basename -oa 123 456
  $basename 456 -or 123
  $basename --required=123 --optional=123 --another=123
  $basename --required=123 --optional --another=123
  $basename --required=123 --noshort=123 --another=123
  $basename --required=123 --noshort --another=123
  $basename --required=123 -o
  $basename --required=123 -o 456 789
  $basename --required=123 -oa 123
  $basename --required=123 -o 456 --another=123 789
%
method
getOpts: optionsSpec
	| argStream opt theArgs specsDict |
	specsDict := self _specsDictFor: optionsSpec.
	args := {}.
	theArgs := self scriptArgs asArray.
	theArgs size = 1 ifTrue: [ ^self ].
	argStream := ReadStream on: (theArgs copyFrom: 2 to: theArgs size).
	[ argStream atEnd ] 
		whileFalse: [
			| optOrArg |
			optOrArg := argStream next.
			(optOrArg = '--' or: [optOrArg = '-'])
				ifTrue: [ self error: 'Cannot handle naked dashes ', optOrArg printString ].
			opt 
				ifNotNil: [ :theOpt |
					theOpt argExpected
						ifTrue: [
							(optOrArg beginsWith: '-')
								ifTrue: [
									theOpt argRequired
										ifTrue: [ self error: 'Missing required argument for option [a] ', opt longName printString ]
										ifFalse: [ theOpt markNoValue "will pick up default value" ] ]
								ifFalse: [ theOpt value: optOrArg ] ]
						ifFalse: [
 							theOpt value: true	"set value to true, to indicate that the option WAS specified" ] ].
			(optOrArg beginsWith: '-')
				ifTrue: [ 
					(optOrArg beginsWith: '--')
						ifTrue: [
							| optKey |
							optKey :=  optOrArg copyFrom: 3 to: optOrArg size.
							(optKey indexOf: $= ifAbsent: [])
								ifNotNil: [ :index |
									"long option with value"
									| arg |
									arg := optKey copyFrom: index + 1 to: optKey size.
									optKey := optKey copyFrom: 1 to: index - 1.
									opt := (specsDict at: 'long') 
										at: optKey 
										ifAbsent: [ self error: 'Unknown option [a] ', optKey printString ].
									opt argExpected
											ifFalse: [ self error: 'Unexpected argument ', arg printString, ' for option ', optKey printString ].
									opt value: arg ]
								ifNil: [
									"naked long option"
									opt := (specsDict at: 'long') 
										at: optKey
										ifAbsent: [ self error: 'Unknown option [b] ', optKey printString ].
									opt argRequired
										ifTrue: [ self error: 'Missing required argument for option [b] ', optKey printString ].
									opt argExpected
                     ifTrue: [ opt markNoValue ]
                     ifFalse: [ opt value: true ] ].
							opt := nil ]
						ifFalse: [
							"optOrArg beginsWith: '-'"
							| theOpts numOpts |
							theOpts :=  optOrArg copyFrom: 2 to: optOrArg size.
							numOpts := theOpts size.
							1 to: numOpts do: [:index |
								| optKey |
								optKey := (theOpts at: index) asString.
								opt := (specsDict at: 'short') 
									at: optKey
									ifAbsent: [ self error: 'Unknown option [c] ', optKey printString ].
								index < numOpts
									ifTrue: [
										"multiple options"
										opt argRequired
											ifTrue: [ self error: 'Missing required argument for option [c] ', opt longName printString ].
										opt argExpected
											ifTrue: [ opt markNoValue ]
											ifFalse: [ opt value: true ] ]
									ifFalse: [
										opt argExpected 
											ifFalse: [
												opt value: true.
												opt := nil ] ] ] ] ]
				ifFalse: [
"if arg is enclosed in "" then they need to be stripped"
					opt 
						ifNil: [ 
							"naked arg"
							args add: optOrArg ]
						ifNotNil: [ "op has already had it's option set" opt := nil ] ] ].
		opt ifNotNil: [
			"naked option"
			opt argRequired
				ifTrue: [ self error: 'Missing required argument for option [d] ', opt longName printString ].
			opt argExpected
				ifTrue: [ opt markNoValue ]
				ifFalse: [  opt value: true ] ].
%
method
_specsDictFor: optionsSpec
	| specsDict |
	specsDict := Dictionary new
		at: 'long' put: Dictionary new;
		at: 'short' put: Dictionary new;
		yourself.
	optionsSpec do: [:option |
		(specsDict at: 'long') 
			at: option longName put: option.
		option shortName ifNotNil: [:shortName |
			(specsDict at: 'short') 
				at: shortName put: option ] ].
	^ specsDict
%
method
commandSummary
	| opts |
	opts := Dictionary new.
	self optionSpecs do: [:option |
		option wasSet
			ifTrue: [ opts at: option longName put: option value ] ].
	^ Dictionary new
		at: 'options' put: opts;
		at: 'args' put: args; 
		yourself.
%
doit
	[
		self getOpts: self optionSpecs.
	] on: Error do: [:ex | 
		self debug ifFalse: [ ^ ex description ].
		ex pass ].
	self help ifTrue: [ ^ self usage ].
	^ self commandSummary
%

